{"version":3,"file":"app.js","mappings":";;;;;;;;;;AAAa;AACb,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,sCAAgB;AAClD;AACA;AACA;;;;;;;;;;;ACJa;AACb,QAAQ,YAAY,EAAE,mBAAO,CAAC,iEAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACPa;AACb,QAAQ,QAAQ,EAAE,mBAAO,CAAC,mEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;AC7GJ;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCXA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://promise-ax/./app.js","webpack://promise-ax/./src/index.js","webpack://promise-ax/./src/main/iterative.promise.js","webpack://promise-ax/./src/main/utils/general.utils.js","webpack://promise-ax/webpack/bootstrap","webpack://promise-ax/webpack/before-startup","webpack://promise-ax/webpack/startup","webpack://promise-ax/webpack/after-startup"],"sourcesContent":["\"use strict\";\r\nconst { createPromise } = require('./src/index.js');\r\nmodule.exports = {\r\n    createPromise: createPromise,\r\n};\r\n","\"use strict\";\r\nconst { PromiseAx } = require('./main/iterative.promise');\r\nconst createPromise = () => {\r\n    return new PromiseAx();\r\n}\r\nmodule.exports = {\r\n    createPromise: createPromise,\r\n};\r\n","\"use strict\";\r\nconst { Utils } = require(\"./utils/general.utils.js\");\r\nclass PromiseAx {\r\n    /**\r\n     * Lo que primero se cumpla, es lo que se devuelve.\r\n     */\r\n    #promiseWithTimeOut(promise, time, messageTimeOut) {\r\n        let timer;\r\n        let error = messageTimeOut ? new Error(messageTimeOut) : new Error(\"Request timed out\");\r\n        return Promise.race([\r\n            promise,\r\n            new Promise((_, rej) => timer = setTimeout(rej(error), time))\r\n        ]).finally(() => clearTimeout(timer));\r\n    }\r\n    all(iterable) {\r\n        if (Utils.isEmpty(iterable) === true) {\r\n            return this.resolve([]);\r\n        }\r\n        return Promise.all(iterable);\r\n    }\r\n    allSettledWithTimeOut(iterable, timeout, messageTimeOut = \"\") {\r\n        if (Utils.isEmpty(iterable) === true) {\r\n            return this.resolve([]);\r\n        }\r\n        if (Utils.isEmpty(timeout) || isNaN(Number(timeout)) === true || timeout < 0) {\r\n            return this.reject(new Error(\"Timeout is not defined\"));\r\n        }\r\n        return new Promise((resolve, _reject) => {\r\n            const results = [];\r\n            var index = 0;\r\n            var completed = 0;\r\n            const length = iterable.length;\r\n            while (index < length) {\r\n                const indexCurrent = index;\r\n                try {\r\n                    let value = iterable[index];\r\n                    this.#promiseWithTimeOut(value, timeout, messageTimeOut).then((result) => {\r\n                        completed++;\r\n                        results[indexCurrent] = result;\r\n                        if (completed == iterable.length) {\r\n                            resolve(results);\r\n                        }\r\n                    }).catch((error) => {\r\n                        completed++;\r\n                        results[indexCurrent] = error;\r\n                        if (completed == iterable.length) {\r\n                            resolve(results);\r\n                        }\r\n                    });\r\n                } catch (error) {\r\n                    completed++;\r\n                    results[indexCurrent] = error;\r\n                    if (completed == iterable.length) {\r\n                        resolve(results);\r\n                    }\r\n                } finally {\r\n                    ++index;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    allSettled(iterable) {\r\n        if (Utils.isEmpty(iterable) === true) {\r\n            return this.resolve([]);\r\n        }\r\n        return new Promise((resolve, _reject) => {\r\n            const results = [];\r\n            var index = 0;\r\n            var completed = 0;\r\n            const length = iterable.length;\r\n            while (index < length) {\r\n                const indexCurrent = index;\r\n                try {\r\n                    let value = iterable[index];\r\n                    this.resolve(value).then((result) => {\r\n                        completed++;\r\n                        results[indexCurrent] = result;\r\n                        if (completed == iterable.length) {\r\n                            resolve(results);\r\n                        }\r\n                    }).catch((error) => {\r\n                        completed++;\r\n                        results[indexCurrent] = error;\r\n                        if (completed == iterable.length) {\r\n                            resolve(results);\r\n                        }\r\n                    });\r\n                } catch (error) {\r\n                    completed++;\r\n                    results[indexCurrent] = error;\r\n                    if (completed == iterable.length) {\r\n                        resolve(results);\r\n                    }\r\n                } finally {\r\n                    ++index;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    race(iterable) {\r\n        return Promise.race(iterable);\r\n    }\r\n    reject(reason) {\r\n        return Promise.reject(reason);\r\n    }\r\n    resolve(value) {\r\n        return Promise.resolve(value);\r\n    }\r\n}\r\nexports.PromiseAx = PromiseAx;","\"use strict\";\r\nexports.Utils = class Utils {\r\n  static isEmpty(value) {\r\n    if (value === undefined || value === null || value === \"\") {\r\n      return true;\r\n    }\r\n    if (Array.isArray(value) === true) {\r\n      return value.length === 0;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./app.js\");\n",""],"names":[],"sourceRoot":""}